
Permanent Gallery â€“ Implementation Spec (Revised)
=================================================

Overview
--------
Persistent, scalable gallery with Create / Gallery / Trash sidebar, PostgreSQL + S3
storage, realâ€‘time updates, bulk actions, and tight integration with the existing
GPTâ€‘Imageâ€‘1 workflow.

Environment
-----------
```
DATABASE_URL=postgresql://user:pass@host:5432/aiimagecraft
S3_ENDPOINT=https://s3.amazonaws.com        # or R2 endpoint
S3_BUCKET=aiimagecraft-images
S3_KEY=...
S3_SECRET=...
JWT_SECRET=change_me                        # for future auth
```
```
npm i prisma @prisma/client        @aws-sdk/client-s3 @aws-sdk/s3-request-presigner        uuid ws react-window
```

1. Database schema (PrismaÂ +Â Postgres)
--------------------------------------
`prisma/schema.prisma`
```prisma
model Image {
  id         String        @id @default(uuid())
  userId     String
  prompt     String
  model      String
  params     Json
  width      Int
  height     Int
  s3Url      String        @unique
  thumbUrl   String
  costTokens Int?          // optional, fill when you calculate
  starred    Boolean       @default(false)
  deletedAt  DateTime?     // null = active, not null = in Trash
  createdAt  DateTime      @default(now())

  sources    SourceImage[]
  @@index([createdAt])
}

model SourceImage {
  id        String   @id @default(uuid())
  imageId   String
  s3Url     String
  thumbUrl  String

  Image     Image    @relation(fields:[imageId], references:[id], onDelete: Cascade)
  @@index([imageId])
}
```
```
npx prisma migrate dev -n init
```

2. S3 helper (`server/s3.ts`)
-----------------------------
```ts
import { S3Client, PutObjectCommand, GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const s3 = new S3Client({
  endpoint:  process.env.S3_ENDPOINT,
  region:    "auto",
  credentials: {
    accessKeyId:     process.env.S3_KEY!,
    secretAccessKey: process.env.S3_SECRET!,
  },
});

const B = process.env.S3_BUCKET!;

export const putObject = (Key:string, Body:Buffer, ContentType:string) =>
  s3.send(new PutObjectCommand({ Bucket:B, Key, Body, ContentType }));

export const signedUrl = (Key:string, expires = 60 * 60 * 24) =>     // 24â€¯h
  getSignedUrl(s3, new GetObjectCommand({ Bucket:B, Key }), { expiresIn:expires });
```

3. WebSocket server (`server/ws.ts`)
------------------------------------
```ts
import { WebSocketServer } from "ws";
import jwt from "jsonwebtoken";

const wss = new WebSocketServer({ noServer:true });

export const push = (ev:string, data:any) =>
  wss.clients.forEach(c => c.send(JSON.stringify({ ev, data })));

export const attachWS = (server:any) => {
  server.on("upgrade", (req,sock,head) => {
    const token = req.headers["sec-websocket-protocol"] as string;
    try {
      jwt.verify(token, process.env.JWT_SECRET!);
      wss.handleUpgrade(req,sock,head, ws => wss.emit("connection", ws, req));
    } catch {
      sock.destroy();
    }
  });
};
```

4. Express server bootstrap
---------------------------
```ts
import { createServer } from "http";
const server = createServer(app);
attachWS(server);

// long timeouts to let heavy jobs finish
server.headersTimeout   = 300_000;
server.keepAliveTimeout = 300_000;

server.listen(3000);
```

5. Job worker â€“ save to S3 + DB
-------------------------------
```ts
import { v4 as uuid } from "uuid";
import sharp from "sharp";
import prisma from "./prisma";
import { putObject, signedUrl, push } from "./s3";

export async function persistImage(b64:string, meta:{ prompt:string; params:any; userId:string; sources:string[]; }) {
  const id     = uuid();
  const imgBuf = Buffer.from(b64, "base64");

  // metadata
  const { width, height } = await sharp(imgBuf).metadata();

  // thumbnail 256â€¯px
  const thumbBuf = await sharp(imgBuf).resize(256).png().toBuffer();

  await Promise.all([
    putObject(`${id}.png`,  imgBuf,  "image/png"),
    putObject(`${id}_t.png`,thumbBuf,"image/png"),
  ]);

  const image = await prisma.image.create({
    data: {
      id,
      userId: meta.userId,
      prompt: meta.prompt,
      model:  "gpt-image-1",
      params: meta.params,
      width, height,
      s3Url:    `${id}.png`,
      thumbUrl: `${id}_t.png`,
      sources: {
        create: meta.sources.map(src => ({
          s3Url:   src,
          thumbUrl: ""      // fill if you store source thumbs
        }))
      }
    }
  });

  push("imageCreated", { image: {
    ...image,
    thumbSigned: signedUrl(image.thumbUrl, 3600)   // 1 h signed link
  }});
  return image;
}
```

6. Gallery API routes
---------------------
```ts
app.get("/api/gallery", async (req,res) => {
  const { cursor, limit = 50, starred, trash } = req.query;
  const where:any = { userId:"demo" };
  if (starred) where.starred = true;
  if (trash)   where.deletedAt = { not: null };
  else         where.deletedAt = null;

  const items = await prisma.image.findMany({
    where,
    take: +limit,
    orderBy:{ createdAt: "desc" },
    ...(cursor ? { cursor:{ id: cursor as string } } : {}),
  });

  const signed = items.map(i => ({
    ...i,
    thumbSigned: signedUrl(i.thumbUrl, 3600),
  }));

  res.json({ items: signed, nextCursor: items.at(-1)?.id });
});

app.patch("/api/image/:id", async (req,res) => {
  const { starred, deleteToTrash } = req.body;
  await prisma.image.update({
    where:{ id: req.params.id },
    data: deleteToTrash ? { deletedAt: new Date() } : { starred }
  });
  res.json({ ok:true });
});
```

7. React sidebar & routing
--------------------------
```tsx
<Sidebar>
  <SidebarLink to="/"         icon={<Sparkles />}>Create</SidebarLink>
  <SidebarLink to="/gallery"  icon={<Images   />}>Gallery</SidebarLink>
  <SidebarLink to="/trash"    icon={<Trash2   />}>Trash</SidebarLink>
</Sidebar>
```
*Use Tailwind default colors; no Midjourney styling.*

Routes:

```
/           -> <CreatePage/>
/gallery    -> <GalleryPage/>
/trash      -> <GalleryPage mode="trash"/>
```

8. GalleryPage
--------------
* Infinite scroll with `useInfiniteQuery` + `react-window` for virtualisation.
* Query key includes `{ starred, trash }` filters.
* Tile component shows thumb, prompt tooltip, â˜…, âœŽ, ðŸ—‘, â¤“.
* When âœŽ clicked: `navigate("/"); ctx.setSourceImages([signedFullUrl]);`.

9. Bulk actions
---------------
In GalleryPage store `selectedIds[]`.

```tsx
<Button onClick={()=> mutateStar(selectedIds,true)}>Star</Button>
<Button onClick={()=> mutateTrash(selectedIds)}>Move to Trash</Button>
```
Backâ€‘end endpoint: `PATCH /api/images/bulk`.

10. Cleanup job
---------------
```ts
import cron from "node-cron";
cron.schedule("0 3 * * *", async () => {
  const old = await prisma.image.findMany({
    where:{ deletedAt:{ lt: subDays(new Date(),30) }}
  });
  for (const img of old) {
    await prisma.image.delete({ where:{ id: img.id }});
    await s3.send(new DeleteObjectCommand({ Bucket:B, Key: img.s3Url }));
    await s3.send(new DeleteObjectCommand({ Bucket:B, Key: img.thumbUrl }));
  }
});
```
If Replit sleeps, trigger cleanup via external cron hitting `/api/cleanup`.

11. Frontâ€‘end context
---------------------
`EditorContext` (already implemented) now also holds `pendingJobs[]` so Gallery updates automatically when WebSocket `imageCreated` arrives.

12. Performance & UX
--------------------
* Thumbs are WebP (`sharp().webp({ quality:90 })`) if browser supports.
* Blurâ€‘up LQIP using CSS `filter: blur(10px)` until full thumb loads.
* Collapse sidebar on `<md` breakpoint, toggle via hamburger.

---

Selfâ€‘check
-----------
âœ”  Uses AWS SDK v3, no deprecated packages.  
âœ”  Prisma schema includes indexes, cascade, softâ€‘delete.  
âœ”  Thumbnails generated before upload, size & metadata read from Sharp.  
âœ”  WebSocket authenticated via JWT header.  
âœ”  Cursor pagination without `skip` to avoid duplicates.  
âœ”  Temp & S3 cleanup defined.  
âœ”  No external styling copied; layout only.  
âœ”  Promise timeouts handled by long headersTimeout, with async job pattern already in place.  

This spec is ready for implementation with minimal rework.
