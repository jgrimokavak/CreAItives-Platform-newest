
🎯 Objective:
Ensure that the email preview and export features match exactly what is rendered in the Email Builder.

---

🔍 Problem:
Currently, the `handlePreviewEmail` function in `client/src/pages/EmailBuilderPage.tsx` is sending only high-level fields like `subject`, `header`, `body`, etc., and is not including the `emailComponents` array in the request to `/api/email/generate-html`.

As a result, the backend is falling back to the legacy template renderer instead of using the custom component-based renderer.

---

✅ Solution:
Update the frontend code to send `emailComponents` when triggering the preview/export request.

Locate this function in:
client/src/pages/EmailBuilderPage.tsx

And modify the POST body of the `fetch` call in `handlePreviewEmail` to include the components:

```ts
const response = await fetch('/api/email/generate-html', {
  method: 'POST',
  body: JSON.stringify({
    subject: emailContent.subject,
    header: emailContent.header,
    body: emailContent.body,
    cta: emailContent.cta,
    templateType: selectedTemplate,
    components: emailComponents // <-- add this line
  }),
  headers: { 'Content-Type': 'application/json' }
});
```

This allows the backend to use the correct rendering logic:
```ts
if (components && Array.isArray(components)) {
  html = generateHTML({ subject, components, includeKavakFooter: true });
} else {
  html = generateLegacyEmailHTML({...});
}
```

---

🧪 Testing:
1. Open the Email Builder.
2. Add multiple components with styling and alignment.
3. Click “Preview” (new window) → confirm the layout matches the on-canvas version.
4. Click “Download HTML” → open the HTML file and confirm identical output to builder.
5. Confirm fallback behavior still works when no components are used.

---

📌 Constraints:
- Do not affect the legacy rendering fallback.
- Ensure this change only applies to the preview/export logic.
- No changes needed to the backend; it already supports this structure.

---

After this fix, the builder, preview window, and exported HTML should all render consistently based on the user’s custom layout.
