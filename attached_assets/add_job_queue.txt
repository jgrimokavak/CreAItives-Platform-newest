
Async job pattern to avoid connection drops
==========================================

Problem
-------
8 images (total ~30 MB) × n=10 × quality=high → OpenAI latency > 30 s.  
Replit’s reverse‑proxy closes idle HTTP connections, so client sees
“Connection error” after ~40 s even though the job continues on the server.

Solution
--------
Process long edits in a background job and let the client poll.

Backend changes
---------------
1. **Job store**
   ```ts
   interface Job {
     id: string;
     status: "pending" | "processing" | "done" | "error";
     result?: GeneratedImage[];
     error?: string;
   }
   const jobs = new Map<string, Job>();
   ```

2. **POST /api/edit-image**  
   ```ts
   app.post("/api/edit-image", upload.fields([...]), (req,res)=>{
     const id = crypto.randomUUID();
     jobs.set(id,{ id, status:"pending" });
     process.nextTick(()=> runEditJob(id, req) );   // fire and forget
     res.status(202).json({ jobId:id });
   });
   ```

3. **GET /api/job/:id**  
   ```ts
   app.get("/api/job/:id", (req,res)=>{
     const job = jobs.get(req.params.id);
     if (!job) return res.status(404).json({msg:"not found"});
     res.json(job);
   });
   ```

4. **runEditJob** (extract existing logic)
   ```ts
   async function runEditJob(id:string, req:Request){
     const job = jobs.get(id)!;
     job.status = "processing";
     try {
       const result = await performImageEdit(req);   // current OpenAI call
       job.status = "done";
       job.result = result;
     } catch(e:any){
       job.status = "error";
       job.error  = e.message;
     }
   }
   ```

5. **Cleanup**  
   Periodically prune finished jobs older than e.g. 30 min.

Client changes
--------------
1. After POST returns `{ jobId }`, start polling:
   ```ts
   const poll = setInterval(async()=>{
     const j = await fetch(`/api/job/${jobId}`).then(r=>r.json());
     if (j.status==="done"){ clearInterval(poll); setGallery(j.result); }
     if (j.status==="error"){ clearInterval(poll); toast.error(j.error); }
   }, 2500);
   ```

2. Show spinner / progress bar while `status!=="done"`.

Quick mitigation (optional)
---------------------------
If you need a stop‑gap, raise timeouts:

```ts
server.headersTimeout   = 300000; // 5 min
server.keepAliveTimeout = 300000;
```

but Replit may still cut the response; the job pattern is robust.

Outcome
-------
Client never waits on a long-lived HTTP request; large high‑latency edits
complete reliably without “Connection error”, and UI shows progress.
