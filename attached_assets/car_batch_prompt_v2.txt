
Batch Car Image Generation – Implementation Guide
=================================================

**Scope**  
Add a “Batch” mode to the existing **Car Creation** page that lets users upload
a CSV (≤ 50 rows) and receive a ZIP of generated car images. Uses Replicate
**google/imagen‑3**. Single‑image mode remains unchanged. **Do not modify
ImageCard.**

CSV spec
--------
Header row, case‑insensitive column names:

| Column         | Required | Example             |
|----------------|----------|---------------------|
| make           | no       | Toyota              |
| model          | no       | Corolla             |
| body_style     | no       | Sedan               |
| trim           | no       | XLE                 |
| year           | no       | 2022                |
| color          | no       | red                 |
| background     | no (default white) | hub OR white |
| aspect_ratio   | no (default 1:1)   | 16:9 |

Rows > 50 are rejected.

Backend
-------

### 1. Job store & queue
```ts
type BatchJob = {
  id: string;
  total: number;
  done: number;
  failed: number;
  zipPath?: string;
  errors: { row:number; reason:string }[];
};
const jobs = new Map<string,BatchJob>();
import PQueue from "p-queue";
const queue = new PQueue({ concurrency: 3 });
```

### 2. POST /api/car-batch
```ts
import multer from "multer";
const upload = multer();
app.post("/api/car-batch", upload.single("file"), async (req,res)=>{
  const csvBuf = req.file?.buffer;
  if (!csvBuf) return res.status(400).json({msg:"file required"});

  const rows = Papa.parse<Row>(csvBuf.toString(),{header:true,skipEmptyLines:true}).data.slice(0,50);
  if (rows.length===0) return res.status(400).json({msg:"no rows"});

  const id = crypto.randomUUID();
  const job:BatchJob = { id, total: rows.length, done:0, failed:0, errors:[] };
  jobs.set(id, job);

  queue.add(()=> processBatch(id, rows));   // async
  res.status(202).json({ jobId:id });
});
```

### 3. GET /api/batch/:id
```ts
app.get("/api/batch/:id", (req,res)=>{
  const j = jobs.get(req.params.id);
  if (!j) return res.sendStatus(404);
  res.json({
    total:j.total, done:j.done, failed:j.failed,
    percent: Math.round((j.done+j.failed)/j.total*100),
    zipUrl: j.zipPath ? `/downloads/${path.basename(j.zipPath)}` : null
  });
});
```

### 4. processBatch()
```ts
async function processBatch(id:string, rows:Row[]){
  const tmpDir = `/tmp/batch_${id}`;
  fs.mkdirSync(tmpDir);

  for (let i=0;i<rows.length;i++){
    const r = rows[i]; const job = jobs.get(id)!;

    try {
      const prompt = buildPrompt(r);
      const pred   = await replicatePredict("google/imagen-3",{ prompt, aspect_ratio:r.aspect_ratio||"1:1", safety_filter_level:"block_only_high" });
      const imgBuf = await fetch(pred.output).then(r=>r.arrayBuffer());

      const filename = makeFilename(r, i);
      fs.writeFileSync(path.join(tmpDir, filename), Buffer.from(imgBuf));
      job.done++;
    } catch(e:any){
      job.failed++; job.errors.push({row:i+2,reason:e.message});
    }
  }

  // ZIP
  const zipPath = `/tmp/${id}.zip`;
  await new Promise((res,rej)=>{
    const out = fs.createWriteStream(zipPath);
    const arch = archiver("zip");
    arch.directory(tmpDir, false)
        .append(Buffer.from(makeErrorCsv(jobs.get(id)!.errors)), { name:"failed_rows.csv" })
        .pipe(out);
    arch.finalize();
    out.on("close", res); arch.on("error", rej);
  });
  jobs.get(id)!.zipPath = zipPath;
  fs.rmSync(tmpDir,{recursive:true,force:true});
}
```

### 5. Helpers
```ts
function makeFilename(r:Row, idx:number){
  const parts = [r.make, r.model, r.year, r.body_style, r.trim, (r.background||"white").toUpperCase()]
    .filter(Boolean).map(s=>s.replace(/\s+/g,"_"));
  return (parts.join("-") || `car-${idx}`)+".png";
}

function buildPrompt(r:Row){
  const tpl = (r.background==="hub") ? PROMPTS.hub : PROMPTS.white;
  return tpl.replace("{{year}}",r.year||"")
            .replace("{{make}}",r.make||"")
            .replace("{{model}}",r.model||"")
            .replace("{{body_style}}",r.body_style||"")
            .replace("{{color}}",r.color||"")
            .replace(/\s+/g," ").trim();
}

function makeErrorCsv(list){ ... } // compile errors to CSV
```

### 6. Static downloads & cleanup
```ts
app.use("/downloads", express.static("/tmp", { maxAge:"1d" }));
cron.schedule("0 * * * *", ()=> {
  fs.readdirSync("/tmp").filter(f=>f.endsWith(".zip")).forEach(f=>{
    const p=`/tmp/${f}`; if (Date.now()-fs.statSync(p).mtimeMs>6*3600*1000) fs.unlinkSync(p);
  });
});
```

Front‑end
---------

### 1. UI toggle
```tsx
<Tabs items={["Single","Batch"]} value={mode} onChange={setMode}/>
```
Batch mode displays a CSV drop‑zone and preview table.

### 2. CSVUpload
* Accept `.csv`, parse with PapaParse.
* Show preview (first 10 rows) and count.
* Reject > 50 rows (toast).
* Start Batch → POST `/api/car-batch` (multipart).

### 3. BatchProgress
* Poll `/api/batch/:id` every 2 s.
* Display progress bar and counts.
* When `zipUrl` present show **Download ZIP** button.

### 4. Validation
* Check header columns; highlight unknowns; allow missing ones.

### 5. UX copy
“Upload a CSV with up to 50 rows. Columns: make, model, body_style, trim, year, color, background (white/hub), aspect_ratio (1:1,16:9,9:16,4:3,3:4).”

Testing
-------
- Upload 10-row CSV → ZIP downloads, 10 images.  
- Upload 55 rows → UI blocks with error.  
- Missing background column → default white.  
- Failed rows recorded in `failed_rows.csv`.

No changes to ImageCard or existing pages.
